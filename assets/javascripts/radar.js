function createVulnerabilityMap(data) {
  const colors = d3.scaleLinear()
    .domain([0, 1])
    .range(['#2c7bb6', '#d7191c']);
  const parkingMap = d3.select('.climate-map');
  const path = d3.geoPath().projection(null);
  parkingMap.append('g')
    .attr('class', 'climate-map__heat')
    .selectAll('path')
    .data(data)
    .enter()
    .append('path')
    .attr('fill', d => colors(d.properties.vul_ht))
    .attr('opacity', '0.8')
    .attr('class', 'census-tract')
    .attr('d', path)
    .on('click', data => updateChart(data) )
}

function addUpdateButtons() {
  d3.select('.layer-select').on('change', updateVulnerabilityMap)
}

function updateVulnerabilityMap() {
  const colors = d3.scaleLinear()
    .domain([0, 1])
    .range(['#2c7bb6', '#d7191c']);
  d3.selectAll('.climate-map__heat > *')
    .attr('fill', data => colors(data.properties[this.value]))
}

function zoomed() {
  d3.selectAll('.climate-map__heat')
    .selectAll('path,circle')
    .attr('transform', d3.event.transform);
}

function addZoomToMaps() {
  const zoom = d3.zoom()
      .scaleExtent([1, 8])
      .on('zoom', zoomed);
  d3.select('.climate-map').call(zoom);
}

function updateChart(data, index="vul_ht") {
  drawSpiderChart(data, index)
}

function spiderChartFramework() {
  const features = ["Exposure","Sensitivity","Adaptive Capacity"];
  const containerWidth = 380
  const containerHeight = 380
  const ticks = [.2,.4,.6,.8,1];

  let svg = d3.select(".spider-chart")
  .attr("width", containerWidth)
  .attr("height", containerHeight)

// Draw triangle guidelines
  ticks.forEach(t => {
    const ninetyDegrees = angleToCoordinate((Math.PI/2), t)
    const twoTenDegrees = angleToCoordinate((7*Math.PI / 6), t)
    const threeThirtyDegrees = angleToCoordinate((11*Math.PI / 6), t)

    svg.append("line")
    .attr("x1", ninetyDegrees.x)
    .attr("y1", ninetyDegrees.y)
    .attr("x2", threeThirtyDegrees.x)
    .attr("y2", threeThirtyDegrees.y)
    .attr("stroke","#C6C6C6")

    svg.append("line")
    .attr("x1", ninetyDegrees.x)
    .attr("y1", ninetyDegrees.y)
    .attr("x2", twoTenDegrees.x)
    .attr("y2", twoTenDegrees.y)
    .attr("stroke","#C6C6C6")

    svg.append("line")
    .attr("x1", twoTenDegrees.x)
    .attr("y1", twoTenDegrees.y)
    .attr("x2", threeThirtyDegrees.x)
    .attr("y2", threeThirtyDegrees.y)
    .attr("stroke", "#C6C6C6")
  })

  // Draw axis lines
  for (var i = 0; i < features.length; i++) {
    let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
    let line_coordinate = angleToCoordinate(angle, 1);

    svg.append("line")
    .attr("x1", 190)
    .attr("y1", (190))
    .attr("x2", line_coordinate.x)
    .attr("y2", line_coordinate.y)
    .attr("stroke","#101436")
    .attr("stroke-width", 1.5)
  }

  // Add tick markings
  ticks.forEach(t => {
    const ninetyDegrees = angleToCoordinate((Math.PI/2), t)
    const twoTenDegrees = angleToCoordinate((7*Math.PI / 6), t)
    const threeThirtyDegrees = angleToCoordinate((11*Math.PI / 6), t)
    svg.append("text")
    .attr("x", (ninetyDegrees.x) + 5)
    .attr("y", (ninetyDegrees.y) + 15)
    .text(t.toString())
    .attr("font-size", 10)

    if (t !== 1){
      svg.append("text")
      .attr("x", twoTenDegrees.x - 5)
      .attr("y", twoTenDegrees.y - 7)
      .text(t.toString())
      .attr("font-size", 10)
    }

    if (t !== .2) {
      svg.append("text")
      .attr("x", threeThirtyDegrees.x - 30)
      .attr("y", threeThirtyDegrees.y )
      .text(t.toString())
      .attr("font-size", 10)
    }
  })
}

function drawSpiderChart(inputData, index) {
  d3.select('.spider-chart').selectAll("path").remove()
  let data;
  switch (index) {
    case "vul_ht":
      data = {
        "Exposure": inputData.properties.vul_ht,
        "Sensitivity": inputData.properties.sens_ht,
        "Adaptive Capacity": inputData.properties.ac_ht
      }
      break;
    case "vul_fz":
      data = {
        "Exposure": inputData.properties.vul_fz,
        "Sensitivity": inputData.properties.sens_fz,
        "Adaptive Capacity": inputData.properties.ac_fz
      }
      break;
    case "vul_8in":
      data = {
        "Exposure": inputData.properties.vul_8in,
        "Sensitivity": inputData.properties.sens_8in,
        "Adaptive Capacity": inputData.properties.ac_8in
      }
      break;
    case "vul_339":
      data = {
        "Exposure": inputData.properties.vul_339,
        "Sensitivity": inputData.properties.sens_339,
        "Adaptive Capacity": inputData.properties.ac_339
      }
      break;
  }

  let line = d3.line()
  .x(d => d.x)
  .y(d => d.y);

  let coordinates = getPathCoordinates(data);
  d3.select('.spider-chart').append("path")
  .datum(coordinates)
  .attr("d",line)
  .attr("stroke-width", 3)
  .attr("stroke", "#DB9E00")
  .attr("fill", "#DB9E00")
  .attr("stroke-opacity", 1)
  .attr("opacity", 0.6);
}

function getPathCoordinates(data_point){
  let coordinates = [];
  const features = ["Exposure","Sensitivity","Adaptive Capacity"];
  for (var i = 0; i < features.length; i++) {
    let ft_name = features[i];
    let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
    coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
  }
  return coordinates;
}

function angleToCoordinate(angle, value) {
  let radialScale = d3.scaleLinear()
  .domain([0,1])
  .range([0,100]);

  const triangleWidth = 200
  const triangleHeight = 200
  const x = Math.cos(angle) * radialScale(value) + 90;
  const y = Math.sin(angle) * radialScale(value) - 90;
  return {"x": (triangleWidth/2) + x, "y": (triangleHeight/2) - y};
}
function distributionChartFramework() {
  let svg = d3.select(".box-plots__heat")
  .attr("width", 380)
  .attr("height", 35)

  svg.append("line")
  .attr("x1", 0)
  .attr("x2", 380)
  .attr("y1", 18)
  .attr("y2", 18)
  .attr("stroke","#0F113D");

  svg.append("line")
  .attr("x1", 0)
  .attr("x2", 0)
  .attr("y1", 13)
  .attr("y2", 22)
  .attr("stroke","#0F113D");

  svg.append("line")
  .attr("x1", 380)
  .attr("x2", 380)
  .attr("y1", 13)
  .attr("y2", 22)
  .attr("stroke","#0F113D");
}

function drawBoxChart(extractedData, tract) {
  const noNulls = extractedData.features.filter(datum => datum.properties.vul_ht > -9).map(datum => datum.properties.vul_ht)
  const median = d3.median(noNulls)
  const firstQuantile = d3.quantile(noNulls, .25)
  const thirdQuantile = d3.quantile(noNulls, .75)
  let distributionScale = d3.scaleLinear()
  .domain([0,1])
  .range([0,385]);

  let svg = d3.select(".box-plots__heat")

  svg.append("rect")
  .attr("x", distributionScale(firstQuantile))
  .attr("y", 5)
  .attr("width", distributionScale(thirdQuantile) - distributionScale(firstQuantile))
  .attr("height", 25)
  .attr("fill", "white")
  .attr("stroke", "#0F113D")

  svg.append("line")
  .attr("x1", distributionScale(median))
  .attr("y1", 5)
  .attr("x2", distributionScale(median))
  .attr("y2", 30)
  .attr("stroke", "#0F113D")
  .attr("stroke-width", 1)

  svg.append("line")
  .attr("x1", distributionScale(extractedData.features[tract].properties.vul_ht))
  .attr("y1", 0)
  .attr("x2", distributionScale(extractedData.features[tract].properties.vul_ht))
  .attr("y2", 35)
  .attr("stroke", "#E0A801")
  .attr("stroke-width", 5)
}

window.addEventListener('DOMContentLoaded', () => {
  Promise.all([
    d3.json('/assets/data/final-dataset-with-percentile-rank.json'),
  ]).then((data) => {
    const extractedData = topojson.feature(data[0], data[0].objects['layer1']);
    const tractEleven = data[0].objects['layer1'].geometries[11];
    spiderChartFramework()
    distributionChartFramework()
    drawSpiderChart(tractEleven, "vul_ht")
    drawBoxChart(extractedData, "11")
    document.querySelector(".toggle").addEventListener("change", function() {
      updateChart(tractEleven, document.querySelector(".toggle").value)
    })
    const topology = topojson.feature(data[0], data[0].objects['layer1']);
    createVulnerabilityMap(topology.features);
    addUpdateButtons();
    addZoomToMaps();
  });
});
